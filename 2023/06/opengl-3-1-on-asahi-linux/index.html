<!doctype html><html lang=en>
<head>
<meta charset=utf-8>
<title>OpenGL 3.1 on Asahi Linux - Asahi Linux</title><link rel=stylesheet href=/css/main.css?e3d0c6ce>
<link href=https://use.fontawesome.com/releases/v5.6.1/css/all.css rel=stylesheet>
<link rel=preconnect href=https://fonts.gstatic.com>
<link id=favicon rel=icon href=/img/AsahiLinux_logomark_32px.png>
<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@300&family=Noto+Sans+JP:wght@300;500;700&family=Noto+Serif+JP:wght@200;500&family=Varela+Round&display=swap" rel=stylesheet>
<meta name=viewport content="width=device-width,initial-scale=1,minimum-scale=1,user-scalable=yes">
<meta name=twitter:card content="summary">
<meta name=twitter:site content="@AsahiLinux">
<meta name=twitter:creator content="@AsahiLinux">
<meta name=twitter:title content="OpenGL 3.1 on Asahi Linux - Asahi Linux">
<meta name=twitter:description content="Porting Linux to Apple Silicon">
<meta name=twitter:image content="https://asahilinux.org/img/AsahiLinux_logomark_256px.png">
<meta name=twitter:image:width content="256">
<meta name=twitter:image:height content="256">
<meta property="og:image" content="https://asahilinux.org/img/AsahiLinux_logomark_256px.png">
<meta property="og:title" content="OpenGL 3.1 on Asahi Linux - Asahi Linux">
</head><body>
<header id=header>
<div class=header-logo>
<a href=/><img src=/img/AsahiLinux_logo.svg?d619e737 class=logo alt></a>
</div><div class=header-menu>
<ul class="menu-container flex-container">
<li><a href=/about>About</a></li><li><a href=/community>Community</a></li><li><a href=/contribute>Contribute</a></li><li><a href=https://github.com/AsahiLinux>GitHub</a></li><li><a href=https://github.com/AsahiLinux/docs/wiki>Wiki</a></li><li><a href=/blog>Blog</a></li><li><a href=/support>Donate</a></li></ul></div></header><section id=post-section>
<div class=post-wrapper>
<div class=post>
<div id=breadcrumbs>
<a href=https://asahilinux.org/>
<i class="fas fa-home"></i>
</a>
/
<a href=https://asahilinux.org/blog/>
Blog
</a>
/
<a href=https://asahilinux.org/2023/06/opengl-3-1-on-asahi-linux/>
OpenGL 3.1 on Asahi Linux
</a>
</div><div class=blog-header>
<h1 class=entry-title>OpenGL 3.1 on Asahi Linux</h1><ul class=blog-nav>
<li>
<a href=https://asahilinux.org/2023/03/road-to-vulkan/><i class="fas fa-arrow-left"></i>Previous</a>
</li><li class=nav-spacer></li><li>
<a class=next href=https://asahilinux.org/2023/08/fedora-asahi-remix/>Next<i class="fas fa-arrow-right"></i></a>
</li></ul></div><p>Upgrade your <a href=https://asahilinux.org/>Asahi Linux</a> systems, because your
graphics drivers are getting a big boost: leapfrogging from OpenGL 2.1 over
OpenGL 3.0 up to OpenGL 3.1! Similarly, the OpenGL ES 2.0 support is bumping up
to OpenGL ES 3.0. That means more playable games and more functioning
applications.</p><p>Back in December, I teased an early screenshot of SuperTuxKart&rsquo;s deferred
renderer working on Asahi, using OpenGL ES 3.0 features like multiple render
targets and instancing. Now you too can enjoy SuperTuxKart with advanced
lighting the way it&rsquo;s meant to be:</p><figure class=captioned>
<img src=/img/blog/2023/06/STK-1080p.webp alt="SuperTuxKart rendering with advanced lighting">
<figcaption><p>SuperTuxKart rendering with advanced light</p></figcaption></figure><p>As before, these drivers are experimental and not yet conformant to the OpenGL
or OpenGL ES specifications. For now, you&rsquo;ll need to run our <code>-edge</code> packages
to opt-in to the work-in-progress drivers, understanding that there may be
bugs. Please refer to <a href=https://asahilinux.org/2022/12/gpu-drivers-now-in-asahi-linux/>our previous
post</a>
explaining how to install the drivers and how to report bugs to help us
improve.</p><p>With that disclaimer out of the way, there&rsquo;s a LOT of new functionality packed
into OpenGL 3.0, 3.1, and OpenGL ES 3.0 to make this release. Highlights
include:</p><ul>
<li>Multiple render targets</li><li>Multisampling</li><li><a href="https://cgit.freedesktop.org/mesa/mesa/commit/?id=d72e1418ce4f66c42f20779f50f40091d3d310b0">Transform feedback</a></li><li><a href=https://social.treehouse.systems/@alyssa/109542058314148170>Texture buffer objects</a></li><li>..and more.</li></ul><p>For now, let&rsquo;s talk about&mldr;</p><h2 id=multisampling>Multisampling</h2><p>Vulkan and OpenGL support <em>multisampling</em>, short for <em>multisampled
anti-aliasing</em>. In graphics, <em>aliasing</em> causes jagged diagonal edges due to
rendering at insufficient resolution. One solution to aliasing is rendering at
higher resolutions and scaling down. Edges will be blurred, not jagged, which
looks better. Multisampling is an efficient implementation of that idea.</p><p>A <em>multisampled</em> image contains multiple <em>samples</em> for every pixel. After
rendering, a multisampled image is <em>resolved</em> to a regular image with one
sample per pixel, typically by averaging the samples within a pixel.</p><p>Apple GPUs support multisampled images and framebuffers. There&rsquo;s quite a bit of
typing to plumb the programmer&rsquo;s view of multisampling into the form understood
by the hardware, but there&rsquo;s no fundamental incompatibility.</p><p>The trouble comes with <em>sample shading</em>. Recall that in modern graphics, the
colour of each <em>fragment</em> is determined by running a <em>fragment shader</em> given by
the programmer. If the fragments are pixels, then each sample within that pixel
gets the same colour. Running the fragment shader once per pixel still benefits
from multisampling thanks to higher quality rasterization, but it&rsquo;s not as good
as <em>actually</em> rendering at a higher resolution. If instead the fragments are
samples, each sample gets a unique colour, equivalent to rendering at a higher
resolution (supersampling). In Vulkan and OpenGL, fragment shaders generally
run per-pixel, but with &ldquo;sample shading&rdquo;, the application can force the
fragment shader to run per-sample.</p><p>How does sample shading work from the drivers&rsquo; perspective? On a typical GPU,
it is simple: the driver compiles a fragment shader that calculates the colour
of a single sample, and sets a hardware bit to execute it per-sample instead of
per-pixel. There is only one bit of state associated with sample shading. The
hardware will execute the fragment shader multiple times per pixel, writing out
pixel colours independently.</p><p>Easy, right?</p><p>Alas, Apple&rsquo;s &ldquo;AGX&rdquo; GPU is not typical.</p><p>AGX always executes the shader once per pixel, not once per sample, like older
GPUs that did not support sample shading. AGX <em>does</em> support it, though.</p><p>How? The AGX instruction set allows pixel shaders to output different colours
to each sample. The instruction used to output a colour<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> takes a <em>set</em> of samples to
modify, encoded as a bit mask. The default all-1&rsquo;s mask writes the same value
to all samples in a pixel, but a mask setting a single bit will write only the
single corresponding sample.</p><p>This design is unusual, and it requires driver backflips to translate &ldquo;fragment
shaders&rdquo; into hardware pixel shaders. How do we do it?</p><p>Physically, the hardware executes our shader once per pixel. Logically, we&rsquo;re
supposed to execute the application&rsquo;s fragment shader once per sample. If we
know the number of samples per pixel, then we can wrap the application&rsquo;s shader
in a loop over each sample. So, if the original fragment shader is:</p><pre tabindex=0><code>interpolated colour = interpolate at current sample(input colour);
output current sample(interpolated colour);
</code></pre><p>then we will transform the program to the pixel shader:</p><pre tabindex=0><code>for (sample = 0; sample &lt; number of samples; ++sample) {
    sample mask = (1 &lt;&lt; sample);
    interpolated colour = interpolate at sample(input colour, sample);
    output samples(sample mask, interpolated colour);
}
</code></pre><p>The original fragment shader runs inside the loop, once per sample. Whenever it
interpolates inputs at the current sample position, we change it to instead
interpolate at a specific sample given by the loop counter <code>sample</code>. Likewise,
when it outputs a colour for a sample, we change it to output the colour to the
single sample given by the loop counter.</p><p>If the story ended here, this mechanism would be silly. Adding
sample masks to the instruction set is more complicated than a single bit to
invoke the shader multiple times, as other GPUs do. Even Apple&rsquo;s own Metal
driver has to implement this dance, because Metal has a similar approach to
sample shading as OpenGL and Vulkan. With all this extra complexity, is there a
benefit?</p><p>If we generated that loop at the end, maybe not. But if we know at compile-time
that sample shading is used, we can run our full optimizer on this sample loop.
If there is an expression that is the same for all samples in a pixel, it can
be hoisted out of the loop.<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup> Instead of
calculating the same value multiple times, as other GPUs do, the value can be
calculated just once and reused for each sample. Although it complicates the
driver, this approach to sample shading isn&rsquo;t Apple cutting corners. If we
slapped on the loop at the end and did no optimizations, the resulting code
would be comparable to what other GPUs execute in hardware. There might be
slight differences from spawning fewer threads but executing more control flow
instructions<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>, but that&rsquo;s minor. Generating the loop early and running the optimizer
enables better performance than possible on other GPUs.</p><p>So is the mechanism only an optimization? Did Apple stumble on a better
approach to sample shading that other GPUs should adopt? I wouldn&rsquo;t be so sure.</p><p>Let&rsquo;s pull the curtain back. AGX has its roots as a <em>mobile</em> GPU intended for
iPhones, with significant PowerVR heritage. Even if it powers Mac Pros today,
the mobile legacy means AGX prefers software implementations of many features
that desktop GPUs implement with dedicated hardware.</p><p>Yes, I&rsquo;m talking about blending.</p><p>Blending is an operation in graphics APIs to combine the fragment shader
output colour with the existing colour in the framebuffer. It is usually used
to implement <a href=https://en.wikipedia.org/wiki/Alpha_compositing>alpha blending</a>,
to let the background poke through translucent objects.</p><p>When multisampling is used <em>without</em> sample shading, although the fragment
shader only runs once per pixel, blending happens per-sample. Even if the
fragment shader outputs the same colour to each sample, if the framebuffer
already had different colours in different samples, blending needs to happen
per-sample to avoid losing that information already in the framebuffer.</p><p>A traditional desktop GPU blends with dedicated hardware. In the
mobile space, there&rsquo;s a mix of dedicated hardware and software. On AGX,
blending is purely software. Rather than configure blending hardware, the
driver must produce <em>variants</em> of the fragment shader that include
instructions to implement the desired blend mode. With alpha
blending, a fragment shader like:</p><pre tabindex=0><code>colour = calculate lighting();
output(colour);
</code></pre><p>becomes:</p><pre tabindex=0><code>colour = calculate lighting();
dest = load destination colour;
alpha = colour.alpha;
blended = (alpha * colour) + ((1 - alpha) * dest));
output(blended);
</code></pre><p>Where&rsquo;s the problem?</p><p>Blending happens per sample. Even if the application intends to run
the fragment shader per pixel, the shader <em>must</em> run per sample for
correct blending. Compared to other GPUs, this approach to blending would
regress performance when blending and multisampling are enabled but sample
shading is not.</p><p>On the other hand, exposing multisample pixel shaders to the driver solves the
problem neatly. If both the blending and the multisample state are known, we
can first insert instructions for blending, and then wrap with the sample loop.
The above program would then become:</p><pre tabindex=0><code>for (sample = 0; sample &lt; number of samples; ++sample_id) {
    colour = calculate lighting();

    dest = load destination colour at sample (sample);
    alpha = colour.alpha;
    blended = (alpha * colour) + ((1 - alpha) * dest);

    sample mask = (1 &lt;&lt; sample);
    output samples(sample_mask, blended);
}
</code></pre><p>In this form, the fragment shader is asymptotically worse than the application
wanted: the fragment shader is executed inside the loop, running per-sample
unnecessarily.</p><p>Have no fear, the optimizer is here. Since <code>colour</code> is the same for each sample
in the pixel, it does not depend on the sample ID. The compiler can move the
entire original fragment shader (and related expressions) out of the per-sample
loop:</p><pre tabindex=0><code>colour = calculate lighting();
alpha = colour.alpha;
inv_alpha = 1 - alpha;
colour_alpha = alpha * colour;

for (sample = 0; sample &lt; number of samples; ++sample_id) {
    dest = load destination colour at sample (sample);
    blended = colour_alpha + (inv_alpha * dest);

    sample mask = (1 &lt;&lt; sample);
    output samples(sample_mask, blended);
}
</code></pre><p>Now blending happens per sample but the application&rsquo;s fragment shader runs just
once, matching the performance characteristics of traditional GPUs. Even
better, all of this happens without any special work from the compiler. There&rsquo;s
no magic multisampling optimization happening here: it&rsquo;s just a loop.</p><p>By the way, what do we do if we <em>don&rsquo;t</em> know the blending and multisample state
at compile-time? Hope is not lost&mldr;</p><p>&mldr;but that&rsquo;s a story for another day.</p><h2 id=whats-next>What&rsquo;s next?</h2><p>While OpenGL ES 3.0 is an improvement over ES 2.0, we&rsquo;re not done. In my
work-in-progress branch, OpenGL ES 3.1 support is nearly finished, which will
unlock compute shaders.</p><p>The final goal is a Vulkan driver running modern games. We&rsquo;re a while away, but
the baseline Vulkan 1.0 requirements parallel OpenGL ES 3.1, so our work
translates to Vulkan. For example, the multisampling compiler passes described
above are common code between the drivers. We&rsquo;ve tested them against OpenGL,
and now they&rsquo;re ready to go for Vulkan.</p><p>And yes, <a href=https://github.com/ella-0>the team</a> is already working on Vulkan.</p><p>Until then, you&rsquo;re one <code>pacman -Syu</code> away from enjoying OpenGL 3.1!</p><div class=footnotes role=doc-endnotes>
<hr>
<ol>
<li id=fn:1>
<p>Store a formatted value to local memory acting as a tilebuffer.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2>
<p>Via <a href=https://en.wikipedia.org/wiki/Common_subexpression_elimination>common subexpression
elimination</a> if
the <a href=https://en.wikipedia.org/wiki/Loop_unrolling>loop is unrolled</a>, otherwise
via <a href=https://en.wikipedia.org/wiki/Code_motion>code motion</a>.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3>
<p>Since the number of samples is constant, all threads branch in the same direction so the usual &ldquo;GPUs are bad at branching&rdquo; advice does not apply.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div><div class=post-bottom>Alyssa Rosenzweig · <span class=publishdate>2023-06-06</span></div></div></div></section><div id=hnwrapper class="jfk-bubble gtx-bubble">
</div><style>.hnsucks{position:fixed;left:0;top:0;width:100%;height:100%;background-color:#fff;display:block;z-index:10000000000;pointer-events:none;mix-blend-mode:multiply;text-align:center}.hnsucks:visited{background-color:#000}.hnsucks2{padding:20px;height:auto;color:#000;background-color:#000;mix-blend-mode:lighten}.hnsucks2:visited{color:#fff}.hnsucks2 code{color:inherit}</style><script>fetch&&CSS.supports("mix-blend-mode","multiply")&&fetch("https://cdn.asahilinux.org/.h",{method:"GET"}).then(e=>e.json()).then(e=>{let t=document.getElementById("hnwrapper");e.forEach(e=>{let n=document.createElement("a");n.ariaHidden=!0,n.tabIndex=-1,n.classList.add("hnsucks"),n.rel="nofollow",n.href=e;let s=n.cloneNode();s.classList.add("hnsucks2"),s.innerHTML="Hi! It looks like you might have come from Hacker News (if you didn't, try turning off dark mode).<br><br>We're going to be blunt: Hacker News is increasingly a haven for alt-right trolls and hateful abusers, and the administrators have demonstrated that they have no interest in improving the situation despite repeated pleas by multiple people, in public and in private, even going as far as deploying countermeasures to prevent us from blocking HN traffic. A significant number of Hacker News commenters have repeatedly directed harassment, abuse, doxxing, and bigotry at multiple Asahi Linux developers, and much of this content remains available and not flagged or downvoted.<br><br>The open source community cannot stand to accept this kind of conduct. Many of us are members of minorities and regularly subject to abuse by these kinds of online communities. Without diverse developers, there would be no Asahi Linux.<br><br>These abusers may not use curse words or blatant slurs as often in HN as they do in other communities, but the messages they spread and brigade on the site are just as hateful and damaging as what you will find in other darker corners of the web, and anyone familiar with such conduct will have no trouble noticing the prevalence of dog whistling, bad faith arguments, and discourse aimed at marginalizing minorities under the guise of polite discussion in many HN threads. We understand that not all Hacker News users are like this. However, by letting these vocal users run undeterred, Y Combinator and Daniel Gackle are tacitly approving of this abuse and hurting the reputation of the entire site and its userbase. If you want to support us and what we do and you are a Hacker News user, please bring this up and demand change within the community.<br><br>As things stand today, we consider Hacker News traffic to be a net negative for the project (yes, it's that bad), and we kindly ask you to move on to the next story.",t.appendChild(n),t.appendChild(s)})})</script>
<footer id=footer>
<div class=footer-menu>
<div class=footer-logo>
<a href=/>
<img src=/img/AsahiLinux_logomark.svg class=logo alt="Asahi Linux logo">
</a>
<span class=license>Licensed under CC BY-SA 4.0</span>
<span class=disclaimer>Linux® is the registered trademark of Linus Torvalds in the U.S. and other countries. All other product names, logos, and brands are property of their respective owners.</span>
</div><div class=footer-links>
<ul class=footer-services>
<li><a href=https://social.treehouse.systems/@AsahiLinux><i class="fab fa-mastodon"></i></a></li><li><a href=https://github.com/AsahiLinux><i class="fab fa-github"></i></a></li><li><a href=https://www.patreon.com/marcan><i class="fab fa-patreon"></i></a></li></ul><ul class=footer-menu-container>
<li><a href=/about>About</a></li><li><a href=/code-of-conduct>Code of Conduct</a></li><li><a href=/copyright>Copyright policy</a></li></ul></div></div></footer></body></html>